#ifndef _M2UHELPER_H_
#define _M2UHELPER_H_

namespace m2uHelper
{

/**
 * Tries to set the Actor's FName to the desired name, while also setting the Label
 * to the exact same name as the FName has resulted in.
 * The returned FName may differ from the desired name, if that was not valid or
 * already in use.
 *
 * @param Actor The Actor which to edit
 * @param Name The desired new name as a string
 *
 * @return FName The resulting ID (and Label-string)
 *
 * The Label is a friendly name that is displayed everywhere in the Editor and it
 * can take special characters the FName can not. The FName is referred to as the
 * object ID in the Editor. Labels need not be unique, the ID must.
 *
 * There are a few functions which are used to set Actor Labels and Names, but all
 * allow a desync between Label and FName, and sometimes don't change the FName
 * at all if deemed not necessary.
 *
 * But we want to be sure that the name we provide as FName is actually set *if*
 * the name is still available.
 * And we want to be sure the Label is set to represent the FName exactly. It might
 * be very confusing to the user if the Actor's "Name" as seen in the Outliner in
 * the Editor is different from the name seen in the Program, but the objects still
 * are considered to have the same name, because the FName is correct, but the
 * Label is desynced.
 *
 * What we have is:
 * 'SetActorLabel', which is the recommended way of changing the name. This function
 * will set the Label immediately and then try to set the ID using the Actor's
 * 'Rename' method, with names generated by 'MakeObjectNameFromActorLabel' or
 * 'MakeUniqueObjectName'. The Actor's Label and ID are not guaranteed to match
 * when using 'SetActorLabel'.
 * 'MakeObjectNameFromActorLabel' will return a name, stripped of all invalid
 * characters. But if the names are the same, and the ID has a number suffix and
 * the label not, the returned name will not be changed.
 * (rename "Chair_5" to "Chair" will return "Chair_5" although I wanted "Chair")
 * So even using 'SetActorLabel' to set the FName to something unique, based
 * on the Label, and then setting the Label to what ID was returned, is not an
 * option, because the ID might not result in what we provided, even though the
 * name is free and valid.
 *
 * TODO:
 * These functions have the option to create unique names within a specified Outer
 * Object, which might be 'unique within a level'. I don't know if we should
 * generally use globally unique names, or how that might change if we use maya-
 * namespaces for levels.
 */
	FName RenameActor( AActor* Actor, const FString& Name)
	{
		// 1. Generate a valid FName from the String

		FString GeneratedName = Name;
		// create valid object name from the string. (remove invalid characters)
		for( int32 BadCharacterIndex = 0; BadCharacterIndex < ARRAY_COUNT( INVALID_OBJECTNAME_CHARACTERS ) - 1; ++BadCharacterIndex )
		{
			const TCHAR TestChar[2] = { INVALID_OBJECTNAME_CHARACTERS[ BadCharacterIndex ], 0 };
			const int32 NumReplacedChars = GeneratedName.ReplaceInline( TestChar, TEXT( "" ) );
		}
		// is there still a name, or was it stripped completely (pure invalid name)
		// we don't change the name then. The calling function should check
		// this and maybe print an error-message or so.
		if( GeneratedName.IsEmpty() )
		{
			return Actor->GetFName();
		}
		const FName NewFName( *GeneratedName );
		
		
		// 2. Rename the object

		if( Actor->GetFName() == NewFName )
		{
			// the new name and current name are the same. Either the input was 
			// the same, or they differed by invalid chars.
			return Actor->GetFName();
		}

		UObject* NewOuter = NULL; // NULL = use the current Outer
		ERenameFlags RenFlags = REN_DontCreateRedirectors;
		bool bCanRename = Actor->Rename( *NewFName.ToString(), NewOuter, REN_Test | REN_DoNotDirty | REN_NonTransactional | RenFlags );
		if( bCanRename )
		{
			Actor->Rename( *NewFName.ToString(), NewOuter, RenFlags);
		}
		else
		{
			// unable to rename the Actor to that name
			return Actor->GetFName();
		}

		// 3. Get the resulting name
		const FName ResultFName = Actor->GetFName();
		// 4. Set the actor label to represent the ID
		//Actor->ActorLabel = ResultFName.ToString(); // ActorLabel is private :(
		Actor->SetActorLabel(ResultFName.ToString()); // this won't change the ID
		return ResultFName;
	}// FName RenameActor()



} // namespace m2uHelper
#endif /* _M2UHELPER_H_ */
